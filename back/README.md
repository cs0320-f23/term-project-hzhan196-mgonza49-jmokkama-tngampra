# Server-evdalal-kentharit

## Project name: Server
## Team members: Evani Dalal (edalal) and Tharit Ngamprasertsith (tngampra)
Total estimated time it took to complete project: 24 hours
A link to your repo: https://github.com/cs0320-f23/server-evdalal-kentharit

## Design choices -- high level design of your program:

We developed a server that has four different endpoints: load, view, search, and broadband. These endpoints are in the server class. To make a server, we pass in a BroadbandDatasource which is an API from the U.S. Census where we can query into finding out how many people have Internet access or another mocked class called MockedAPICall which mimics the funtionality of the Census API but with mocked data. We also pass in a cache size for the server in order to be able to save time in making API calls. The server sets up four different endpoints as mentioned before.

The load endpoint has a handle class and this is where we load in a file and parse through the file to save it in a List<List<String>> for future use. The load query must take in a filepath to a csv and a hasHeader parameter indicating whether the csv that was passed in has headers or not. If there are headers, "y" or "Y" must be passed in, and if there are no headers, any other string can be passed in. The filepath must be a relative path to server-evdalal-kentharit/data and we restrict it to this when checking if the filepath is valid. The load endpoint checks that these parameters are passed in and then calls the Parse class to parse through the csv and save it in a List<List<String>>. If the filepath that was passed in does not exist, then an exception is outputted. If the load query is successful, then a success message is outputted and the loadhandler class will have a List<List<String>> saved for future reference.

The view endpoint has a handle class and this is where the user can see the contents of the csv that was passed in. In order for the view endpoint to work, a load endpoint query must have been done successfully previously. If an invalid load query was done after a successful one, the last successful query's csv file will be viewed. The handle class checks that the correct number of parameters (0) were passed in and that a load query was done before. 

The search endpoint has a handle class and this is where the user can search through the csv passed in load. In order for a successful query, a successful load query must have been done previously. If there are any invalid queries, the last most successful file passed in will be searched, and if there are no previous valid load queries, then an error is outputted to the user. The user must pass in a column index to search in and if the user does not want to search by column index, then they should input -1. A keyword must be passed in otherwise there is nothing to search. A headerName should be passed in if the user wants to search by header otherwise this can be blank (but the query parameter still must be there in the url). In order to search by header successfully, the user must have indicated that there are headers in the dataset that was loaded in the loadcsv endpoint. If both column index and header are passed in, the search endpoint will search by header first. The searchHandler will call the Parse class which calls the Search class to search to CSV based on the user input. The search class has two types of functions: searchCSV() and narrowAndConductSearch(). narrowAndConductSearch() is called by the Parser class and this first narrows the search based on the column identifier if applicable and then searches the CSV using the searchCSV() function. If a header name is passed in, then to find the header name is not case sensitive. However, in the actual search to see if any rows in the CSV match the keyword, it is case sensitive. For example, a row that contains "hi" will not be matched if the keyword is "HI". The matches are outputted in a success message by the searchHandler class. 

The broadband endpoint has handle class and this is where the user can get data on the internet access rate of different counties in the United States. The broadbandHandler takes in an apiCall which implements a BroadbandDatasource interface and a size for the cache. The user who makes the query must pass in a state and a county. The state must be formatted with a capital first letter and the county must be [county name], [state state] in order to be successful. The first time a query is made, an API call is made to map every state to its corresponding identifier. For counties, an API call is made for each county to get its identifier, no matter how many times the same county is queried. The handle method stores these parameters in an custom InputParams structure to check that these parameters were actually passed in. The county and states are converted to a string that contains an identifier, and a call is made to the Census API to find the broadband access rate. The results are stored in a cache so if multiple of the same query is made, the result is taken from the cache rather than making a new API call. The cache's size can be customized and the number of minutes an entry remains in the cache before it gets evicted can be customized too. 

If the user spells the query parameters wrong, then that query parameter will be null and an exception will be outputted by the handler.

We implemented a cache so that multiple identical calls to the API would not have to be made.

The Census API is built so that there is only data for counties that have a population of >65k. Thus, although a county may exist in a state, there might not be data for it such as Colusa County, California and thus, an exception is outputted. 



## Tests:
We created 5 new test classes and included 2 test classes that test the Parse and Search functionality from the last sprint. 

For load, view, and search Handlers, the tests open up a connection to the localHost port, make a URL with different query parameters, get results, serialize them with a Moshi object, and then clean up Spark. 

The loadHandler tests set up and close out spark before and after each test. The tests for load handle generate different queries where there is a check for not enough or too many parameters, well working paramters, and parameters that are ill formed. These tests check if a success or error message is outputted and that the correct parameters that were passed in are also outputted. Some tests include too many parameters in the query, loading a CSV with headers successfully, loading a CSV without headers successfully, checking that the RI data set from the spec can be loaded and parsed, an empty file, and checking a filepath that does not exist in the folder we restricted filepaths to.

The viewHandlerTest outputs contents of different CSVs. The same setup and teardown process is done before and after each test. Queries are formed to check that the load endpoint has been previously called and this is tested as well. If the loadendpoint is not called, then an error is thrown. Other tests include looking at output of empty CSVs, giving parameters when viewHandler does not take in any, and successfully outputting contents of smaller CSVs.

The searchHandler outputs results from a search query made from different CSVs. The same setup and teardown process is done before and after each test. Queries are formed to check that the load endpoint has been previously called and this is tested as well. Tests include looking for too many parameters, searching by index, searching with an empty keyword, searching by column headers, searching CSVs that have no headers, searching by a columnIndex that does not exist, and searching for a keyword that exists but not in the column specified. 

Broadband has two types of tests. One test makes sure that the API can be called properly and the other test uses Mocked Data to verify the functionality of BroadbandHandler. BroadbandHandlerTest uses the mockedData to test the handler. Based on a given county and state that is passed in, we check if the stateCode and countyCode given back is correct based on the 2010 mapping list and the mocked timestamp is correct, and the mocked broadband rate is correct. Tests include looking for invalid states, valid states but invalid counties, a missing state parameter, and both parameters missing. There is also a unit test to verify the saveStateCode() function where a list of all the states and their codes in the mocked data are outputted. 

BroadbandSourceTest is a form of integration testing that tests the actual API calls by creating a server object which takes in a source of the data (the Census API in this case) and a cacheSize which we kept consistent at 10. We test similar tests as the BroadbandHandlerTest but by making the Census API calls. This includes missing a state or county, an invalid county, an invalid state, and checking for a county that exists but does not have data (Colusa County, California). We also test for a valid query where the broadband access rate is returned.

For all tests, if there are ill formed parameters or invalid ones, a corresponding exception is thrown and this error message is checked.

## How to:
To run the tests, we can do mvn test. To build and run the program, we can run the server class, open up the local host in a browser, and format queries in the URL space in the browser. Everything within the handle methods is within a try catch block, so exceptions should be printed rather than receiving an Internal Server error by Spark.
